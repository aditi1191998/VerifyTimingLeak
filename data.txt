/******************************************************************************/
/** System Parameters *********************************************************/
/******************************************************************************/
/* Highest address that can be used. */
const int LAST_ADDR = 2048;
/* Number of cores. */
const int CORE_COUNT = 1;
/* Number of cache lines found in each cache */
const int LINES_PER_CACHE = 3;
/* Number of components in the system */
const int COMPONENT_COUNT = 16;
const bool USE_LOCK_FREE_CACHES = true;
/******************************************************************************/
/** Types *********************************************************************/
/******************************************************************************/
/**
* Command ID:
*  Identifier corresponding to a request (i.e. LOAD/STORE/EVICT) or
*  query (e.g. GETS/GETM/PUTM).
*/
typedef int[0,/*[EVENT_TYPE_COUNT]*/7/*[/EVENT_TYPE_COUNT]*/] cmd_id_t;
/* Data and instruction addresses */
typedef int[0,LAST_ADDR] addr_t;
/* Unique ID for each system component (used in message passing) */
typedef int[-1,COMPONENT_COUNT] cmp_id_t;
const cmp_id_t CMP_ID_T_NULL = -1;
const int INTERFERENCE_TYPES = 3;
typedef int[0,INTERFERENCE_TYPES] interference_id_t;
const interference_id_t INTERFERENCE_MINOR = 0;
const interference_id_t INTERFERENCE_DEMOTING = 1;
const interference_id_t INTERFERENCE_EXPELLING = 2;
typedef struct
{
   cmp_id_t author;
   addr_t addr;
   cmd_id_t cmd;
} query_t;
/******************************************************************************/
/** Constants & Limits ********************************************************/
/******************************************************************************/
/* Personal preference... */
const bool FALSE = false;
const bool TRUE = true;
/* Range of addresses */
const addr_t ADDR_T_NULL = 0;
const addr_t ADDR_T_MIN = 1;
const addr_t ADDR_T_MAX = LAST_ADDR;
/* How many parameters of each type are found in the transient message. */
const int ADDR_T_PARAMS_MAX = 1;
const int CMP_ID_T_PARAMS_MAX = 2;
/* Array index indicating the emitter of a transient message. */
const int CMP_ID_T_EMITTER_PARAM = 0;
const int CMP_ID_T_RECEIVER_PARAM = 1;
/*[EVENTS_DECLARATION]*/
/* Command IDs corresponding to the cache controller queries. */
const cmd_id_t CMD_CCTRL_GET_SHARED = 0;
const cmd_id_t CMD_CCTRL_GET_MODIFIED = 1;
const cmd_id_t CMD_CCTRL_PUT_MODIFIED = 2;
/* Command IDs corresponding to the cpu requests. */
const cmd_id_t CMD_CCTRL_LOAD = 3;
const cmd_id_t CMD_CCTRL_STORE = 4;
const cmd_id_t CMD_CCTRL_EVICT = 5;
const cmd_id_t CMD_DATA_MSG = 6;
const cmd_id_t CMD_NO_DATA_MSG = 7;
/*[/EVENTS_DECLARATION]*/
/*
 * Total number of cache lines in the system. This is used to know how many
 * addresses should be kept track of.
 */
const int MAX_AMOUNT_OF_CACHED_LINES = (CORE_COUNT * LINES_PER_CACHE);
/** Time **********************************************************************/
const int RAM_READ_TIME = 200;
const int RAM_WRITE_TIME = 200;
const int QUERY_HANDLING_TIME = 1;
const int C2C_DATA_TIME = 2;
const int CLOCK_CYCLE_TIME = 50;
/******************************************************************************/
const query_t DEFAULT_QUERY_VALUE =
    {
        /* author = */ CMP_ID_T_NULL,
        /* addr = */ ADDR_T_NULL,
        /* cmd = */ CMD_DATA_MSG
    };
/******************************************************************************/
/** Channels ******************************************************************/
/******************************************************************************/
/* Signal indicating the initialization of the system */
urgent broadcast chan SYS_INIT;
/* Signal corresponding to a cache controller query passing on the bus */
urgent broadcast chan QUERY_BROADCAST;
urgent chan QUERY_TO_BUS[cmp_id_t];
urgent chan QUERY_IN[cmp_id_t];
urgent chan QUERY_OUT[cmp_id_t];
urgent chan DATA_IN[cmp_id_t];
urgent chan DATA_TRANS[cmp_id_t];
urgent chan DATA_OUT[cmp_id_t];
chan ADD_BUS_MASTER;
/*
 * Signal used by CPUs to send a request to their cache controller (whose ID is
 * the param.
 */
urgent chan CPU_REQ[cmp_id_t];
/*
 * Signal used by cache controllers to acknowledge that a cpu request has been
 * completed. The param corresponds to the ID of the receiving CPU.
 */
urgent chan CPU_ACK[cmp_id_t];
/* Signal used to force a transition to be urgent. */
urgent chan FORCE_URGENT;
urgent chan FORCE_EXTRA_URGENT;
urgent chan MEM_READ;
urgent chan MEM_WRITE;
broadcast chan MAX_PRIORITY;
/* Forces CPUs to make their requests as soon as possible. */
chan priority default < QUERY_IN < DATA_IN < MEM_WRITE < MEM_READ < QUERY_TO_BUS < QUERY_BROADCAST < FORCE_URGENT < QUERY_OUT < CPU_REQ < CPU_ACK < FORCE_EXTRA_URGENT < MAX_PRIORITY;
/******************************************************************************/
/** Channel Parameters Global Variables ***************************************/
/******************************************************************************/
/*
 * Values cannot be passed through channels, instead, we rely on global
 * variables to store them. This would quickly become unsustainable if not for
 * the fact that only a single transition can occur at any one time.
 */
typedef struct
{
   addr_t addr_t_params[ADDR_T_PARAMS_MAX];
   cmp_id_t cmp_id_t_params[CMP_ID_T_PARAMS_MAX];
   cmd_id_t cmd_id_t_param;
} msg_content_t;
/* Default message, used to reset 'msg_content_t' to their default value.
/* const */ msg_content_t DEFAULT_MSG;
/* Variable containing the message sent during the current transition */
meta msg_content_t transient_msg;
/* Reset the transient message to its default value */
void reset_transient_msg ()
{
    transient_msg = DEFAULT_MSG;
}
bool has_use_for_bus[COMPONENT_COUNT];
bool is_ready_for_bus[COMPONENT_COUNT];
cmp_id_t memory_component_for (const addr_t addr)
{
   return 1;
}
process ForceUrgent() {
state
    /** Lets other automata
turn any transition into
an "urgent" one. */
    I0;
init
    I0;
trans
    I0 -> I0 { sync FORCE_EXTRA_URGENT?; },
    I0 -> I0 { sync FORCE_URGENT?; };
}
process CoherencyMGR(cmp_id_t ID, cmp_id_t MEM_ID) {
/* Status of a "coherency" line (real value in RAM vs real value in cache). */
typedef int[0,/*[CMGR_STATES_COUNT]*/3/*[/CMGR_STATES_COUNT]*/] mem_state_t;
/* index of a "coherency" line in this automaton's status tracking array. */
typedef int[-1,MAX_AMOUNT_OF_CACHED_LINES] cache_line_status_ix_t;
/*[CMGR_STATES_DECLARATION]*/
const mem_state_t MEM_U = 0;
const mem_state_t MEM_M = 1;
const mem_state_t MEM_U_D = 2;
const mem_state_t MEM_U_B = 3;
/*[/CMGR_STATES_DECLARATION]*/
/* (address, status) couple for the status tracking array. */
typedef struct
{
   addr_t addr;
   mem_state_t m_state;
   cmp_id_t owner;
} cache_line_status_t;
query_t stalled_query;
bool is_busy, was_stalling;
void push_stalled_query ()
{
   stalled_query.addr = transient_msg.addr_t_params[0];
   stalled_query.cmd = transient_msg.cmd_id_t_param;
   stalled_query.author = transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   is_ready_for_bus[ID] = FALSE;
}
void pop_stalled_query ()
{
   transient_msg.addr_t_params[0] = stalled_query.addr;
   transient_msg.cmd_id_t_param = stalled_query.cmd;
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = stalled_query.author;
   stalled_query = DEFAULT_QUERY_VALUE;
   is_ready_for_bus[ID] = FALSE;
}
void toggle_busy ()
{
   is_busy = !is_busy;
   is_ready_for_bus[ID] = (stalled_query.addr == ADDR_T_NULL) && !is_busy;
}
cache_line_status_t cache_line_status[MAX_AMOUNT_OF_CACHED_LINES];
/* Line of the status tracking array relevant to the current operation. */
cache_line_status_ix_t current_line = -1;
/* Default value for a status tracking array line. */
const cache_line_status_t DEFAULT_CACHE_LINE_STATUS_VALUE =
   {
      /* addr = */ ADDR_T_NULL,
      /* c_state = */ /*[CMGR_DEFAULT_STATE]*/MEM_U/*[/CMGR_DEFAULT_STATE]*/,
      /* owner = */ CMP_ID_T_NULL
   };
cache_line_status_ix_t get_line_of (const addr_t addr)
{
   int i;
   int result;
   result = -1;
   /* Look at all the status tracking array lines */
   for (i = 0; i < MAX_AMOUNT_OF_CACHED_LINES; i++)
   {
      if (cache_line_status[i].addr == addr)
      {
         /* If we've found a match, we're done. */
         return i;
      }
      if
      (
         (result == -1)
         && (cache_line_status[i].m_state == /*[CMGR_DEFAULT_STATE]*/MEM_U/*[/CMGR_DEFAULT_STATE]*/)
      )
      {
         /*
          * If no match has been found so far, and we've got an unused line,
          * consider it to be were we'll store the new status.
          */
         result = i;
      }
   }
   return result;
}
bool relevant_line_is (const mem_state_t m_state)
{
   return (cache_line_status[current_line].m_state == m_state);
}
void set_relevant_line_to (const mem_state_t m_state)
{
   cache_line_status[current_line].m_state = m_state;
}
msg_content_t msg_in;
bool should_act_flag = FALSE;
void handle_put_modified ()
{
   if (current_line == -1)
   {
      return;
   }
   if
   (
      cache_line_status[current_line].owner
      != msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM]
   )
   {
      return;
   }
   if (cache_line_status[current_line].m_state == MEM_M)
   {
      cache_line_status[current_line].owner = CMP_ID_T_NULL;
      cache_line_status[current_line].m_state = MEM_U_D;
   }
   else if (cache_line_status[current_line].m_state == MEM_U_D)
   {
      push_stalled_query();
   }
   else if (cache_line_status[current_line].m_state == MEM_U_D)
   {
      cache_line_status[current_line].owner = CMP_ID_T_NULL;
      cache_line_status[current_line].m_state = MEM_U;
   }
}
/* Update function upon seeing a GetM query. */
void handle_get_modified ()
{
   if (relevant_line_is(MEM_U))
   {
      set_relevant_line_to(MEM_M);
      should_act_flag = TRUE;
      cache_line_status[current_line].owner =
         msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   }
   else if (relevant_line_is(MEM_M))
   {
      cache_line_status[current_line].owner =
         msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   }
   else if (relevant_line_is(MEM_U_D))
   {
      push_stalled_query();
   }
}
/* Update function upon seeing a GetS query. */
void handle_get_shared ()
{
   if (relevant_line_is(MEM_U))
   {
      should_act_flag = TRUE;
   }
   else if (relevant_line_is(MEM_M))
   {
      set_relevant_line_to(MEM_U_D);
      cache_line_status[current_line].owner = CMP_ID_T_NULL;
   }
   else if (relevant_line_is(MEM_U_D))
   {
      push_stalled_query();
   }
   else if (relevant_line_is(MEM_U_B))
   {
      set_relevant_line_to(MEM_U);
      cache_line_status[current_line].owner = CMP_ID_T_NULL;
   }
}
cmp_id_t get_emitter ()
{
    return msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
}
/* Should the "coherency manager" provide a reply to the current query? */
bool should_reply ()
{
   return should_act_flag;
}
bool should_write ()
{
   return should_act_flag;
}
void send_query_to_mem ()
{
   transient_msg = msg_in;
}
void parse_message_content (const bool reset_transient)
{
   msg_in = transient_msg;
   if (reset_transient)
   {
      reset_transient_msg();
   }
   current_line = get_line_of(msg_in.addr_t_params[0]);
   cache_line_status[current_line].addr = msg_in.addr_t_params[0];
}
/* Parses and handles an incoming cache controller request. */
void parse_request ()
{
   cmd_id_t req_in;
   parse_message_content(FALSE);
   req_in = msg_in.cmd_id_t_param;
   /*[CMGR_QUERY_SWITCH]*/
   if (req_in == CMD_CCTRL_GET_SHARED)
   {
      handle_get_shared();
   }
   else if (req_in == CMD_CCTRL_GET_MODIFIED)
   {
      handle_get_modified();
   }
   else if (req_in == CMD_CCTRL_PUT_MODIFIED)
   {
      handle_put_modified();
   }
   /*[/CMGR_QUERY_SWITCH]*/
}
/*[CMGR_HANDLE_DATA_FUNCTIONS]*/
/*[/CMGR_HANDLE_DATA_FUNCTIONS]*/
void parse_data_input ()
{
   cmd_id_t req_in;
   parse_message_content(TRUE);
   req_in = msg_in.cmd_id_t_param;
   /*[CMGR_DATA_SWITCH]*/
   if (relevant_line_is(MEM_M))
   {
      should_act_flag = TRUE;
      set_relevant_line_to(MEM_U_B);
   }
   else if (relevant_line_is(MEM_U_D))
   {
      set_relevant_line_to(MEM_U);
      should_act_flag = TRUE;
   }
   if (stalled_query.addr == cache_line_status[current_line].addr)
   {
      was_stalling = TRUE;
   }
   /*[/CMGR_DATA_SWITCH]*/
}
void clean ()
{
    current_line = -1;
    msg_in = DEFAULT_MSG;
    should_act_flag = FALSE;
}
void initialize ()
{
   int i;
   stalled_query = DEFAULT_QUERY_VALUE;
   was_stalling = FALSE;
   is_busy = FALSE;
   for (i = 0; i < MAX_AMOUNT_OF_CACHED_LINES; i++)
   {
      cache_line_status[i] = DEFAULT_CACHE_LINE_STATUS_VALUE;
   }
   clean();
}
state
    S1,
    S2,
    Ready,
    S0;
commit
    S0;
init
    S0;
trans
    Ready -> S2 { guard was_stalling; sync FORCE_URGENT!; assign pop_stalled_query(),
parse_request(),
toggle_busy(),
was_stalling = FALSE; },
    S1 -> Ready { guard !should_write(); sync FORCE_URGENT!; assign toggle_busy(),
clean(); },
    S1 -> Ready { guard should_write(); sync MEM_WRITE!; assign toggle_busy(),
clean(); },
    S2 -> Ready { guard should_reply(); sync MEM_READ!; assign send_query_to_mem(),
toggle_busy(),
clean(); },
    S2 -> Ready { guard !should_reply(); sync FORCE_URGENT!; assign toggle_busy(),
clean(); },
    Ready -> S2 { sync QUERY_BROADCAST?; assign parse_request(),
toggle_busy(); },
    Ready -> S1 { guard !was_stalling; sync DATA_IN[MEM_ID]?; assign parse_data_input(),
toggle_busy(); },
    S0 -> Ready { sync SYS_INIT?; assign initialize(),
clean(); };
}
process MemoryCTRL(cmp_id_t ID) {
/******************************************************************************/
/** Time **********************************************************************/
/******************************************************************************/
/* Clock to measure time spent during a RAM access. */
clock clk;
cmp_id_t reply_to;
cmd_id_t data_type;
addr_t addr;
void parse_query ()
{
    reply_to = transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
    addr = transient_msg.addr_t_params[0];
    data_type = transient_msg.cmd_id_t_param;
}
void initialize ()
{
    reply_to = CMP_ID_T_NULL;
    addr = ADDR_T_NULL;
    data_type = 0;
}
void emit_data ()
{
    transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
    transient_msg.cmp_id_t_params[CMP_ID_T_RECEIVER_PARAM] = reply_to;
    transient_msg.addr_t_params[0] = addr;
    transient_msg.cmd_id_t_param = data_type;
    initialize();
}
state
    S0,
    S2,
    S1 { clk <= RAM_READ_TIME },
    S3 { clk <= RAM_WRITE_TIME },
    Ready;
init
    S0;
trans
    S0 -> Ready { sync SYS_INIT?; assign initialize(); },
    S2 -> Ready { sync DATA_OUT[ID]!; assign emit_data(),
is_ready_for_bus[ID] = TRUE; },
    S3 -> Ready { guard (clk == RAM_WRITE_TIME); sync MAX_PRIORITY!; assign is_ready_for_bus[ID] = TRUE; },
    S1 -> S2 { guard (clk == RAM_READ_TIME); sync MAX_PRIORITY!; },
    Ready -> S1 { sync MEM_READ?; assign clk = 0,
parse_query(),
is_ready_for_bus[ID] = FALSE; },
    Ready -> S3 { sync MEM_WRITE?; assign clk = 0,
is_ready_for_bus[ID] = FALSE; };
}
process QueryBus(cmp_id_t ID) {
/******************************************************************************/
/** Types *********************************************************************/
/******************************************************************************/
/******************************************************************************/
/** Local Data ****************************************************************/
/******************************************************************************/
/*
 * Busses contain a copy of the messages passing through them. In this case,
 * the content of the message is found in the "params" global variables, which
 * must thus be copied here.
 */
msg_content_t msg;
/* ID of the component that is currently master of the bus. */
int owner;
cmp_id_t bus_master_order[CORE_COUNT];
/******************************************************************************/
/** Transition Functions ******************************************************/
/******************************************************************************/
/* Stores a copy of the transient message. */
void parse_message_content ()
{
   msg = transient_msg;
   reset_transient_msg();
}
/* Writes its internal copy to the transient message. */
void emit_message_content ()
{
   transient_msg = msg;
   msg = DEFAULT_MSG;
}
/* Sets a new bus master according to the current transient message. */
void set_bus_owner ()
{
   owner = transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   msg = transient_msg;
   reset_transient_msg();
}
cmp_id_t get_owner ()
{
   return bus_master_order[owner];
}
bool order_selected ()
{
   return (owner == CORE_COUNT);
}
void add_bus_master ()
{
   bus_master_order[owner] = transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   owner += 1;
}
void select_next_master ()
{
   owner = ((owner + 1) % CORE_COUNT);
}
void initialize ()
{
   int i;
   owner = 0;
   DEFAULT_MSG.addr_t_params[0] = ADDR_T_NULL;
   msg = DEFAULT_MSG;
   reset_transient_msg();
   for (i = 0; i < CORE_COUNT; ++i)
   {
      bus_master_order[i] = ID;
   }
   for (i = 0; i < COMPONENT_COUNT; ++i)
   {
      has_use_for_bus[i] = FALSE;
      is_ready_for_bus[i] = TRUE;
   }
}
bool something_needs_the_bus ()
{
   int i;
   for (i = 0; i < CORE_COUNT; ++i)
   {
      if (has_use_for_bus[bus_master_order[i]])
      {
         return TRUE;
      }
   }
   return FALSE;
}
bool can_broadcast_message ()
{
   int i;
   for (i = 0; i < CORE_COUNT; ++i)
   {
      if (not is_ready_for_bus[bus_master_order[i]])
      {
         return FALSE;
      }
   }
   return is_ready_for_bus[memory_component_for(msg.addr_t_params[0])];
}
state
    S1,
    S2,
    S0,
    Ready;
commit
    S1,
    S0;
init
    S0;
trans
    Ready -> Ready { guard something_needs_the_bus()
&& !has_use_for_bus[get_owner()]; sync FORCE_URGENT!; assign select_next_master(); },
    S1 -> S1 { sync ADD_BUS_MASTER?; assign add_bus_master(); },
    S0 -> S1 { assign initialize(); },
    S2 -> Ready { guard can_broadcast_message(); sync QUERY_BROADCAST!; assign emit_message_content(),
select_next_master(); },
    Ready -> S2 { sync QUERY_TO_BUS[get_owner()]?; assign parse_message_content(); },
    S1 -> Ready { guard order_selected(); sync SYS_INIT!; assign owner = 0; };
}
process DataFIFO(cmp_id_t OWNER_ID) {
const int IN_DATA_BUFFER_SIZE = 2;
const int OUT_DATA_BUFFER_SIZE = IN_DATA_BUFFER_SIZE;
const int MAX_DATA_BUFFER_SIZE = IN_DATA_BUFFER_SIZE;
msg_content_t in_data[MAX_DATA_BUFFER_SIZE];
msg_content_t out_data[MAX_DATA_BUFFER_SIZE];
/**** Internal ****************************************************************/
void pop
(
   msg_content_t &array[MAX_DATA_BUFFER_SIZE],
   const int queue_size
)
{
   int i;
   for (i = 1; i < queue_size; ++i)
   {
      /* No "break" in UPPAAL. */
      if (array[i - 1].addr_t_params[0] == ADDR_T_NULL)
      {
         array[i - 1] = array[i];
         i = queue_size;
      }
      else
      {
         array[i - 1] = array[i];
      }
   }
   array[queue_size - 1] = DEFAULT_MSG;
   array[queue_size - 1].addr_t_params[0] = ADDR_T_NULL;
}
void push
(
   msg_content_t &array[MAX_DATA_BUFFER_SIZE],
   const int queue_size,
   const msg_content_t msg
)
{
   int i;
   for (i = 0; i < queue_size; ++i)
   {
      if (array[i].addr_t_params[0] == ADDR_T_NULL)
      {
         array[i] = msg;
         return;
      }
   }
}
void push_data (msg_content_t &array[MAX_DATA_BUFFER_SIZE], const int array_size)
{
   push(array, array_size, transient_msg);
}
void pop_data (msg_content_t &array[MAX_DATA_BUFFER_SIZE], const int array_size)
{
   transient_msg = array[0];
   pop(array, array_size);
}
/**** Transitions *************************************************************/
cmp_id_t next_target ()
{
   return out_data[0].cmp_id_t_params[CMP_ID_T_RECEIVER_PARAM];
}
bool in_data_not_empty ()
{
   return (in_data[0].addr_t_params[0] != ADDR_T_NULL);
}
bool out_data_not_empty ()
{
   return (out_data[0].addr_t_params[0] != ADDR_T_NULL);
}
bool in_data_not_full ()
{
   return (in_data[IN_DATA_BUFFER_SIZE - 1].addr_t_params[0] == ADDR_T_NULL);
}
bool out_data_not_full ()
{
   return (out_data[OUT_DATA_BUFFER_SIZE - 1].addr_t_params[0] == ADDR_T_NULL);
}
void pop_in_data ()
{
   pop_data(in_data, IN_DATA_BUFFER_SIZE);
}
void pop_out_data ()
{
   pop_data(out_data, OUT_DATA_BUFFER_SIZE);
}
void push_in_data ()
{
   push_data(in_data, IN_DATA_BUFFER_SIZE);
}
void push_out_data ()
{
   push_data(out_data, OUT_DATA_BUFFER_SIZE);
}
void initialize ()
{
   int i;
   for (i = 0; i < MAX_DATA_BUFFER_SIZE; ++i)
   {
      in_data[i] = DEFAULT_MSG;
      out_data[i] = DEFAULT_MSG;
   }
}
state
    S0,
    Ready;
init
    S0;
trans
    S0 -> Ready { sync SYS_INIT?; assign initialize(); },
    Ready -> Ready { guard out_data_not_empty(); sync DATA_TRANS[next_target()]!; assign pop_out_data(); },
    Ready -> Ready { guard out_data_not_full(); sync DATA_OUT[OWNER_ID]?; assign push_out_data(); },
    Ready -> Ready { guard in_data_not_empty(); sync DATA_IN[OWNER_ID]!; assign pop_in_data(); },
    Ready -> Ready { guard in_data_not_full(); sync DATA_TRANS[OWNER_ID]?; assign push_in_data(); };
}
process Core(cmp_id_t ID, cmp_id_t CCTRL, int PROGRAM) {
/******************************************************************************/
/** Types *********************************************************************/
/******************************************************************************/
/*
 * Instruction ID.
 * ID of an 'assembly' instruction.
 */
typedef int[0,4] instr_id_t;
/* Assembly program line. */
typedef struct
{
   instr_id_t instr;
   addr_t addr;
   int min_calc_time;
   int max_calc_time;
} program_line_t;
/******************************************************************************/
/** Constants & Limits ********************************************************/
/******************************************************************************/
/* Ends the program's execution */
const instr_id_t INSTR_LOAD = 0;
const instr_id_t INSTR_STORE = 1;
const instr_id_t INSTR_EVICT = 2;
const instr_id_t INSTR_END = 3;
// Doesn't work, yet.
const instr_id_t INSTR_CALC = 4;
/******************************************************************************/
/** Local Data ****************************************************************/
/******************************************************************************/
/* Used to measure computation times. */
clock clk;
clock runtime;
/* Line of the program the execution is currently at. */
int program_counter = 0;
program_line_t current_program_line;
int current_max_calc_time;
int current_min_calc_time;
int received_acks = 0;
/**** Programs ****************************************************************/
const program_line_t program_0 [7] =
   {
      {INSTR_LOAD,    1, 0, 0},
      {INSTR_LOAD,    2, 0, 0},
      {INSTR_STORE,   3, 0, 0},
      {INSTR_LOAD,    3, 0, 0},
      {INSTR_STORE,   1, 0, 0},
      {INSTR_EVICT,   1, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_101 [7] =
   {
      {INSTR_LOAD,    4, 0, 0},
      {INSTR_LOAD,    5, 0, 0},
      {INSTR_STORE,   6, 0, 0},
      {INSTR_LOAD,    6, 0, 0},
      {INSTR_STORE,   4, 0, 0},
      {INSTR_EVICT,   4, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_200 [11] =
   {
      {INSTR_STORE,   1, 0, 0},
      {INSTR_STORE,   2, 0, 0},
      {INSTR_LOAD,    1, 0, 0},
      {INSTR_STORE,   1, 0, 0},
//      {INSTR_CALC,    0, 200, 300},
      {INSTR_LOAD,    2, 0, 0},
      {INSTR_STORE,   2, 0, 0},
      {INSTR_LOAD,    1, 0, 0},
      {INSTR_STORE,   1, 0, 0},
      {INSTR_LOAD,    2, 0, 0},
      {INSTR_STORE,   2, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_201 [11] =
   {
      {INSTR_STORE,   3, 0, 0},
      {INSTR_STORE,   4, 0, 0},
      {INSTR_LOAD,    3, 0, 0},
      {INSTR_STORE,   3, 0, 0},
      {INSTR_LOAD,    4, 0, 0},
      {INSTR_STORE,   4, 0, 0},
      {INSTR_LOAD,    3, 0, 0},
      {INSTR_STORE,   3, 0, 0},
      {INSTR_LOAD,    4, 0, 0},
      {INSTR_STORE,   4, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_102 [7] =
   {
      {INSTR_LOAD,    7, 0, 0},
      {INSTR_LOAD,    8, 0, 0},
      {INSTR_STORE,   9, 0, 0},
      {INSTR_LOAD,    9, 0, 0},
      {INSTR_STORE,   7, 0, 0},
      {INSTR_EVICT,   7, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_103 [7] =
   {
      {INSTR_LOAD,    10, 0, 0},
      {INSTR_LOAD,    11, 0, 0},
      {INSTR_STORE,   12, 0, 0},
      {INSTR_LOAD,    12, 0, 0},
      {INSTR_STORE,   10, 0, 0},
      {INSTR_EVICT,   10, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_1 [10] =
   {
      {INSTR_STORE,   1, 0, 0},
      {INSTR_LOAD,    1, 0, 0},
      {INSTR_EVICT,   1, 0, 0},
      {INSTR_END,     0, 0, 0},
      {INSTR_LOAD,    4, 0, 0},
//      {INSTR_LOAD,    3, 0, 0},
      {INSTR_LOAD,    1, 0, 0},
      {INSTR_STORE,   2, 0, 0},
      {INSTR_STORE,   1, 0, 0},
      {INSTR_EVICT,   2, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_2 [10] =
   {
      {INSTR_LOAD,   1, 0, 0},
      {INSTR_LOAD,   2, 0, 0},
      {INSTR_LOAD,   3, 0, 0},
      {INSTR_LOAD,   4, 0, 0},
      {INSTR_LOAD,   5, 0, 0},
      {INSTR_LOAD,   2, 0, 0},
      {INSTR_LOAD,   4, 0, 0},
      {INSTR_LOAD,   5, 0, 0},
      {INSTR_LOAD,   1, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_3 [10] =
   {
      {INSTR_STORE,    1, 0, 0},
      {INSTR_STORE,    2, 0, 0},
      {INSTR_STORE,    3, 0, 0},
      {INSTR_STORE,    4, 0, 0},
      {INSTR_STORE,    5, 0, 0},
      {INSTR_STORE,   2, 0, 0},
      {INSTR_STORE,   4, 0, 0},
      {INSTR_STORE,   5, 0, 0},
      {INSTR_STORE,   1, 0, 0},
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_4 [1] =
   {
      {INSTR_END,     0, 0, 0}
   };
const program_line_t program_10 [3] =
   // Tests load and trivial evict
   {
      {INSTR_LOAD, 1, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_EVICT, 1, 0, 0},
      {INSTR_END, 0, 0, 0}
   };
   // Total: 1 RAM_READ_TIME
const program_line_t program_11 [5] =
   {
      {INSTR_STORE, 1, 0, 0}, // 1 RAM_READ_TIME*
      {INSTR_LOAD, 1, 0, 0},
      {INSTR_EVICT, 1, 0, 0},
      {INSTR_LOAD, 1, 0, 0}, // 1 RAM_WRITE_TIME
      {INSTR_END, 0, 0, 0}
   };
   // Total: 1 RAM_READ_TIME + 1 RAM_WRITE_TIME
const program_line_t program_12 [5] =
   // Tests that addresses don't get mixed up when validating existing
   {
      {INSTR_STORE, 1, 0, 0}, // 1 RAM_READ_TIME*
      {INSTR_LOAD, 2, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 1, 0, 0},
      {INSTR_STORE, 2, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_END, 0, 0, 0}
   };
   // Total: 3 RAM_READ_TIME
const program_line_t program_13 [5] =
   {
      {INSTR_LOAD, 1, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 2, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 3, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 1, 0, 0},
      {INSTR_END, 0, 0, 0}
   };
   // Total: 3 RAM_READ_TIME
const program_line_t program_14 [8] =
   {
      {INSTR_LOAD, 1, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 2, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 3, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 4, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 1, 0, 0}, // 0: Available as soon as the first req is completed,
                       // which is before the cache is full.
      {INSTR_LOAD, 3, 0, 0},
      {INSTR_LOAD, 4, 0, 0},
      {INSTR_END, 0, 0, 0}
   };
   // 5 RAM_READ_TIME
const program_line_t program_15 [11] =
   {
      {INSTR_LOAD, 1, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 2, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 3, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_LOAD, 4, 0, 0}, // 1 RAM_READ_TIME. @1 evicted
      {INSTR_STORE, 2, 0, 0}, // 1 RAM_READ_TIME*
      {INSTR_STORE, 3, 0, 0}, // 1 RAM_READ_TIME*
      {INSTR_STORE, 4, 0, 0}, // 1 RAM_READ_TIME*
      {INSTR_LOAD, 1, 0, 0},
      {INSTR_LOAD, 3, 0, 0},
      {INSTR_LOAD, 4, 0, 0},
      {INSTR_END, 0, 0, 0}
   };
const program_line_t program_16 [4] =
   {
      {INSTR_LOAD, 1, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_STORE, 1, 0, 0}, // 1 RAM_READ_TIME
      {INSTR_EVICT, 1, 0, 0}, // 1 RAM_WRITE_TIME
      {INSTR_END, 0, 0, 0}
   };
   // 2 RAM_READ_TIME + 1 RAM_WRITE_TIME
/******************************************************************************/
/** Local Functions ***********************************************************/
/******************************************************************************/
/*
 * Converts an 'instr_id_t' to an 'cmd_id_t', if applicable (i.e. mem and cache
 * related instructions).
 */
cmd_id_t instr_to_cmd (const instr_id_t instr)
{
   if (instr == INSTR_LOAD)
   {
      return /*[CMD_CCTRL_LOAD]*/CMD_CCTRL_LOAD/*[/CMD_CCTRL_LOAD]*/;
   }
   else if (instr == INSTR_STORE)
   {
      return /*[CMD_CCTRL_STORE]*/CMD_CCTRL_STORE/*[/CMD_CCTRL_STORE]*/;
   }
   else if (instr == INSTR_EVICT)
   {
      return /*[CMD_CCTRL_EVICT]*/CMD_CCTRL_EVICT/*[/CMD_CCTRL_EVICT]*/;
   }
   else
   {
      return /*[CMD_CCTRL_EVICT]*/CMD_CCTRL_EVICT/*[/CMD_CCTRL_EVICT]*/;
   }
}
instr_id_t cmd_to_instr (const cmd_id_t cmd)
{
   if (cmd == /*[CMD_CCTRL_LOAD]*/CMD_CCTRL_LOAD/*[/CMD_CCTRL_LOAD]*/)
   {
      return INSTR_LOAD;
   }
   else if (cmd == /*[CMD_CCTRL_STORE]*/CMD_CCTRL_STORE/*[/CMD_CCTRL_STORE]*/)
   {
      return INSTR_STORE;
   }
   else if (cmd == /*[CMD_CCTRL_EVICT]*/CMD_CCTRL_EVICT/*[/CMD_CCTRL_EVICT]*/)
   {
      return INSTR_EVICT;
   }
   else
   {
      return INSTR_END;
   }
}
/* Returns the current program line for this automaton. */
program_line_t get_current_program_line ()
{
   if (PROGRAM == 0)
   {
      return program_0[program_counter];
   }
   else if (PROGRAM == 1)
   {
      return program_1[program_counter];
   }
   else if (PROGRAM == 2)
   {
      return program_2[program_counter];
   }
   else if (PROGRAM == 3)
   {
      return program_3[program_counter];
   }
   else if (PROGRAM == 4)
   {
      return program_4[program_counter];
   }
   else if (PROGRAM == 10)
   {
      return program_10[program_counter];
   }
   else if (PROGRAM == 11)
   {
      return program_11[program_counter];
   }
   else if (PROGRAM == 12)
   {
      return program_12[program_counter];
   }
   else if (PROGRAM == 13)
   {
      return program_13[program_counter];
   }
   else if (PROGRAM == 14)
   {
      return program_14[program_counter];
   }
   else if (PROGRAM == 15)
   {
      return program_15[program_counter];
   }
   else if (PROGRAM == 16)
   {
      return program_16[program_counter];
   }
   else if (PROGRAM == 101)
   {
      return program_101[program_counter];
   }
   else if (PROGRAM == 102)
   {
      return program_102[program_counter];
   }
   else if (PROGRAM == 103)
   {
      return program_103[program_counter];
   }
   else if (PROGRAM == 200)
   {
      return program_200[program_counter];
   }
   else if (PROGRAM == 201)
   {
      return program_201[program_counter];
   }
   else
   {
      return program_202[program_counter];
   }
}
/******************************************************************************/
/** Transition Functions ******************************************************/
/******************************************************************************/
/** Instruction ***************************************************************/
void load_next_instruction ()
{;
    program_counter += 1;
    current_program_line = get_current_program_line();
    current_max_calc_time = current_program_line.max_calc_time;
    current_min_calc_time = current_program_line.min_calc_time;
}
bool next_instruction_is_to_be_sent ()
{
   if (!USE_LOCK_FREE_CACHES && (received_acks != program_counter))
   {
      return FALSE;
   }
   return
      (
         (current_program_line.instr == INSTR_LOAD)
         || (current_program_line.instr == INSTR_STORE)
         || (current_program_line.instr == INSTR_EVICT)
      );
}
bool next_instruction_is (const instr_id_t instr)
{
   return (current_program_line.instr == instr);
}
void emit_next_instruction ()
{
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
   transient_msg.cmd_id_t_param = instr_to_cmd(current_program_line.instr);
   transient_msg.addr_t_params[0] = current_program_line.addr;
   load_next_instruction();
}
void initialize ()
{
   current_program_line = get_current_program_line();
}
state
    S1 { clk <= CLOCK_CYCLE_TIME },
    Terminated,
    S0,
    Ready;
init
    S0;
trans
    S1 -> Ready { guard (clk == CLOCK_CYCLE_TIME); sync MAX_PRIORITY!; assign clk = 0; },
    Ready -> Terminated { guard next_instruction_is(INSTR_END)
&& (received_acks == program_counter); sync FORCE_URGENT!; },
    Ready -> Ready { sync CPU_ACK[ID]?; assign received_acks += 1; },
    Ready -> S1 { guard next_instruction_is_to_be_sent(); sync CPU_REQ[CCTRL]!; assign emit_next_instruction(),
clk = 0; },
    S0 -> Ready { sync SYS_INIT?; assign runtime = 0,
initialize(); };
}
process MSICacheCTRL(cmp_id_t ID, cmp_id_t MEM_ID) {
clock clk;
const int REQ_BUFFER_SIZE = 3;
/* Index of a line in the requests buffer. */
typedef int[-1,REQ_BUFFER_SIZE] pending_request_ix_t;
/* Index of a cache line. */
typedef int[-1,LINES_PER_CACHE] cache_line_ix_t;
/* Rank of a cache line in the LRU order. */
typedef int[0,LINES_PER_CACHE] cache_line_last_use_t;
/* Status of a cache line. */
typedef int[0,/*[CC_STATES_COUNT]*/20/*[/CC_STATES_COUNT]*/] msi_state_t;
/*[CC_STATES_DECLARATION]*/
const msi_state_t MSI_MODIFIED = 0;
const msi_state_t MSI_SHARED = 1;
const msi_state_t MSI_INVALID = 2;
const msi_state_t MSI_IS_BD = 3;
const msi_state_t MSI_IS_B = 4;
const msi_state_t MSI_IS_D = 5;
const msi_state_t MSI_IS_D_I = 6;
const msi_state_t MSI_SM_BD = 7;
const msi_state_t MSI_SM_B = 8;
const msi_state_t MSI_SM_D = 9;
const msi_state_t MSI_SM_D_I = 10;
const msi_state_t MSI_SM_D_S = 11;
const msi_state_t MSI_SM_D_SI = 12;
const msi_state_t MSI_IM_BD = 13;
const msi_state_t MSI_IM_B = 14;
const msi_state_t MSI_IM_D = 15;
const msi_state_t MSI_IM_D_I = 16;
const msi_state_t MSI_IM_D_S = 17;
const msi_state_t MSI_IM_D_SI = 18;
/* Evict from Modified. */
const msi_state_t MSI_MI_B = 19;
/* Evict from Modified, but another cache controller is getting Modified. */
const msi_state_t MSI_II_B = 20;
/*[/CC_STATES_DECLARATION]*/
typedef struct
{
   /* Address this line represents. */
   addr_t addr;
   /* Status associated to the address. */
   msi_state_t c_state;
   /* Rank of the cache line in the LRU order. */
   cache_line_last_use_t last_use;
   /* If the state is AA_B(B?)_C(C?), this is who to send the reply to. */
   cmp_id_t reply_to;
} cache_line_t;
typedef struct
{
   /* ID of the component the acknowledgment will be sent to. */
   cmp_id_t requester;
   /* Address on which the request is made. */
   addr_t addr;
   /* Type of request. */
   cmd_id_t cmd;
   bool is_cache_hit;
} pending_request_t;
typedef struct
{
    int hit;
    int miss;
    int interference_count[INTERFERENCE_TYPES];
    int potential_interference_count[INTERFERENCE_TYPES];
    bool is_being[INTERFERENCE_TYPES];
} cache_local_address_info_t;
query_t current_query;
cache_line_t cache_lines[LINES_PER_CACHE];
/* Line of the cache associated with the current operation. */
cache_line_ix_t current_line = -1;
const cache_line_t DEFAULT_CACHE_LINE_VALUE =
   {
      /* addr = */ ADDR_T_NULL,
      /* c_state = */ /*[CC_DEFAULT_STATE]*/MSI_INVALID/*[/CC_DEFAULT_STATE]*/,
      /* last_use = */ 0,
      /* reply_to = */ CMP_ID_T_NULL
   };
cache_line_ix_t get_line_of (const addr_t addr, const cache_line_t &cache[LINES_PER_CACHE])
{
   int i;
   int result;
   result = -1;
   /* Traverse the cache... */
   for (i = 0; i < LINES_PER_CACHE; i++)
   {
      /* If there's an cache line about the targeted address, we're done. */
      if (cache[i].addr == addr)
      {
         return i;
      }
      /*
       * If we don't already have a result, and there's an empty line, consider
       * the result to be this empty line for now.
       */
      if
      (
         (result == -1)
         &&
         (cache[i].c_state == /*[CC_DEFAULT_STATE]*/MSI_INVALID/*[/CC_DEFAULT_STATE]*/)
      )
      {
         result = i;
      }
   }
   return result;
}
/* Returns the state of the relevant line, or MSI_INVALID if there isn't one. */
msi_state_t get_state_of_relevant_line ()
{
   if (current_line == -1)
   {
      return /*[CC_DEFAULT_STATE]*/MSI_INVALID/*[/CC_DEFAULT_STATE]*/;
   }
   return cache_lines[current_line].c_state;
}
msi_state_t get_state_of (const addr_t addr, const cache_line_t &cache[LINES_PER_CACHE])
{
   const cache_line_ix_t result_ix = get_line_of(addr, cache);
   if (result_ix == -1)
   {
      return /*[CC_DEFAULT_STATE]*/MSI_INVALID/*[/CC_DEFAULT_STATE]*/;
   }
   return cache[result_ix].c_state;
}
/**** Transitions *************************************************************/
/* Tests if the relevant line has the given status. */
bool relevant_line_is (const msi_state_t i_state)
{
   return (get_state_of_relevant_line() == i_state);
}
void set_line_to (const cache_line_ix_t line, const msi_state_t i_state)
{
   if (i_state == /*[CC_DEFAULT_STATE]*/MSI_INVALID/*[/CC_DEFAULT_STATE]*/)
   {
      cache_lines[line].reply_to = CMP_ID_T_NULL;
   }
   cache_lines[line].c_state = i_state;
}
/* Sets the status of the relevant line to the given status. */
void set_relevant_line_to (const msi_state_t i_state)
{
   set_line_to(current_line, i_state);
}
/******************************************************************************/
/** Cache Request Info ********************************************************/
/******************************************************************************/
cache_local_address_info_t cache_local_address_infos[LAST_ADDR];
void mark_as_being (const interference_id_t interference)
{
   const addr_t addr = cache_lines[current_line].addr;
   cache_local_address_infos[addr].potential_interference_count[INTERFERENCE_MINOR] -= 1;
   cache_local_address_infos[addr].potential_interference_count[interference] += 1;
   cache_local_address_infos[addr].is_being[interference] = TRUE;
}
void clear_interference_by_reading ()
{
   const addr_t addr = cache_lines[current_line].addr;
   if (cache_local_address_infos[addr].is_being[INTERFERENCE_EXPELLING])
   {
      cache_local_address_infos[addr].is_being[INTERFERENCE_EXPELLING] = FALSE;
      cache_local_address_infos[addr].interference_count[INTERFERENCE_EXPELLING] += 1;
   }
}
void clear_interference_by_writing ()
{
   const addr_t addr = cache_lines[current_line].addr;
   if (cache_local_address_infos[addr].is_being[INTERFERENCE_EXPELLING])
   {
      cache_local_address_infos[addr].is_being[INTERFERENCE_EXPELLING] = FALSE;
      cache_local_address_infos[addr].interference_count[INTERFERENCE_EXPELLING] += 1;
   }
   if (cache_local_address_infos[addr].is_being[INTERFERENCE_DEMOTING])
   {
      cache_local_address_infos[addr].is_being[INTERFERENCE_DEMOTING] = FALSE;
      cache_local_address_infos[addr].interference_count[INTERFERENCE_DEMOTING] += 1;
   }
}
/******************************************************************************/
/** Eviction Management *******************************************************/
/******************************************************************************/
cache_line_ix_t least_recently_used_line = (LINES_PER_CACHE - 1);
/**** Internal ****************************************************************/
void propagate_use_count (const cache_line_ix_t line_being_used)
{
   cache_line_last_use_t threshold;
   int i;
   threshold = cache_lines[line_being_used].last_use;
   for (i = 0; i < LINES_PER_CACHE; i++)
   {
      if (cache_lines[i].last_use < threshold)
      {
         cache_lines[i].last_use += 1;
      }
      if
      (
         (cache_lines[i].last_use == (LINES_PER_CACHE - 1))
         && (i != line_being_used)
      )
      {
         least_recently_used_line = i;
      }
   }
   cache_lines[line_being_used].last_use = 0;
}
/******************************************************************************/
/** CPU Request Management ****************************************************/
/******************************************************************************/
/*
 * Stalled, active, and completed (but not yet acknowledged) requests.
 * These requests are stored in a FIFO order.
 */
pending_request_t pending_requests[REQ_BUFFER_SIZE];
pending_request_t completed_requests[REQ_BUFFER_SIZE];
pending_request_t blocked_request;
/* Index of the request related to the current operation. */
pending_request_ix_t current_request = -1;
const pending_request_t DEFAULT_PENDING_REQUEST_VALUE =
   {
      /* requester = */  0,
      /* addr = */ ADDR_T_NULL,
      /* cmd = */ 0,
      /* is_cache_hit = */ TRUE
   };
/**** Internal ****************************************************************/
/*
 * Bypasses the FIFO order of 'pending_requests' to ensure that the given
 * request is the next one to go.
 * Currently, the only user would be the internal eviction mechanism.
 */
void force_first_pending_request
(
   pending_request_t &array[REQ_BUFFER_SIZE],
   const int queue_size,
   const pending_request_t request
)
{
   int i;
   /* Move back one cell every request. */
   /* Safe due to pending_requests[REQ_BUFFER_SIZE - 1] being reserved. */
   for (i = queue_size; i > 0; --i)
   {
      array[i] = array[i - 1];
   }
   array[0] = request;
}
/* Adds a request to 'pending_requests' while maintaining the FIFO order. */
void push_new_pending_request
(
   pending_request_t &array[REQ_BUFFER_SIZE],
   const int queue_size,
   const pending_request_t request
)
{
   int i;
   /* Puts the request in the first free pending request slot found. */
   for (i = 0; i < queue_size; ++i)
   {
      if (array[i].addr == ADDR_T_NULL)
      {
         array[i] = request;
         return;
      }
   }
}
void pop_pending_request_at
(
   pending_request_t &array[REQ_BUFFER_SIZE],
   const int queue_size,
   const pending_request_ix_t request_ix
)
{
   int i;
   for (i = (request_ix + 1); i < queue_size; ++i)
   {
      array[i - 1] = array[i];
      if (array[i - 1].addr == ADDR_T_NULL)
      {
         i = queue_size;
      }
   }
   array[queue_size - 1] = DEFAULT_PENDING_REQUEST_VALUE;
}
void mark_current_pending_request_as_cache_miss ()
{
   pending_requests[current_request].is_cache_hit = FALSE;
}
void mark_request_as_completed ()
{
   const pending_request_t req = pending_requests[current_request];
   if (req.is_cache_hit)
   {
      cache_local_address_infos[req.addr].miss += 1;
   }
   else
   {
      cache_local_address_infos[req.addr].miss += 1;
   }
   pop_pending_request_at
   (
      pending_requests,
      REQ_BUFFER_SIZE,
      current_request
   );
   push_new_pending_request
   (
      completed_requests,
      REQ_BUFFER_SIZE,
      req
   );
}
/* Is the requests buffer full? */
bool can_take_requests ()
{
   /*
    * There is at least one free available line in the 'current_request'
    * FIFO (note that [REQ_BUFFER_SIZE - 1] is reserved).
    */
   return
      (
         (pending_requests[REQ_BUFFER_SIZE - 2].addr == ADDR_T_NULL)
         && (blocked_request.addr == ADDR_T_NULL)
      );
}
bool has_pending_request ()
{
    return (pending_requests[0].addr != ADDR_T_NULL);
}
bool has_completed_request ()
{
    return (completed_requests[0].addr != ADDR_T_NULL);
}
/*[CC_HANDLE_STALLED_REQUEST]*/
/* Handles a previously stalled EVICT request becoming active. */
void handle_stalled_evict ()
{
   /** [TEST][HANDLE_STALLED_EVICT] **/
   if (relevant_line_is(MSI_INVALID))
   {
      mark_request_as_completed();
   }
   else if (relevant_line_is(MSI_SHARED))
   {
      mark_request_as_completed();
      set_relevant_line_to(MSI_INVALID);
   }
   else if (relevant_line_is(MSI_MODIFIED))
   {
      mark_current_pending_request_as_cache_miss();
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_PUT_MODIFIED;
      set_relevant_line_to(MSI_MI_B);
      current_request += 1;
   }
}
/* Handles a previously stalled STORE request becoming active. */
void handle_stalled_store ()
{
   /** [TEST][HANDLE_STALLED_STORE] **/
   if (relevant_line_is(MSI_INVALID))
   {
      mark_current_pending_request_as_cache_miss();
      clear_interference_by_writing();
      propagate_use_count(current_line);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_GET_MODIFIED;
      set_relevant_line_to(MSI_IM_BD);
      current_request += 1;
   }
   else if (relevant_line_is(MSI_SHARED))
   {
      mark_current_pending_request_as_cache_miss();
      clear_interference_by_writing();
      propagate_use_count(current_line);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_GET_MODIFIED;
      set_relevant_line_to(MSI_SM_BD);
      current_request += 1;
   }
   else if
   (
      relevant_line_is(MSI_MODIFIED)
      || relevant_line_is(MSI_MI_B)
   )
   {
      clear_interference_by_writing();
      propagate_use_count(current_line);
      mark_request_as_completed();
   }
}
/* Handles a previously stalled LOAD request becoming active. */
void handle_stalled_load ()
{
   /** [TEST][HANDLE_STALLED_LOAD] **/
   if (relevant_line_is(MSI_INVALID))
   {
      mark_current_pending_request_as_cache_miss();
      clear_interference_by_reading();
      propagate_use_count(current_line);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_GET_SHARED;
      set_relevant_line_to(MSI_IS_BD);
      current_request += 1;
   }
   else if
   (
      relevant_line_is(MSI_SHARED)
      || relevant_line_is(MSI_SM_BD)
      || relevant_line_is(MSI_SM_D)
      || relevant_line_is(MSI_SM_B)
      || relevant_line_is(MSI_SM_D_I)
      || relevant_line_is(MSI_SM_D_S)
      || relevant_line_is(MSI_SM_D_SI)
      || relevant_line_is(MSI_MODIFIED)
      || relevant_line_is(MSI_MI_B)
   )
   {
      /*
       * It's actually a bit more complicated than that: all the MSI_SM_* are
       * cache hits on the value BEFORE the write occurs...
       */
      clear_interference_by_reading();
      propagate_use_count(current_line);
      mark_request_as_completed();
   }
}
/*[/CC_HANDLE_STALLED_REQUEST]*/
/*[CC_TEST_UNSTALLS_REQUEST]*/
bool unstalls_evict ()
{
   /** [TEST][UNSTALLS_EVICT] **/
   return
      (
         relevant_line_is(MSI_MODIFIED)
         || relevant_line_is(MSI_INVALID)
         || relevant_line_is(MSI_SHARED)
      );
}
bool unstalls_load ()
{
   /** [TEST][UNSTALLS_LOAD] **/
   return
      (
         relevant_line_is(MSI_INVALID)
         || relevant_line_is(MSI_SHARED)
         || relevant_line_is(MSI_SM_BD)
         || relevant_line_is(MSI_SM_B)
         || relevant_line_is(MSI_SM_D)
         || relevant_line_is(MSI_SM_D_S)
         || relevant_line_is(MSI_SM_D_I)
         || relevant_line_is(MSI_SM_D_SI)
         || relevant_line_is(MSI_MODIFIED)
         || relevant_line_is(MSI_MI_B)
      );
}
bool unstalls_store ()
{
   /** [TEST][UNSTALLS_STORE] **/
   return
      (
         relevant_line_is(MSI_INVALID)
         || relevant_line_is(MSI_SHARED)
         || relevant_line_is(MSI_MODIFIED)
         || relevant_line_is(MSI_MI_B)
      );
}
/*[/CC_TEST_UNSTALLS_REQUEST]*/
bool should_unstall ()
{
   cmd_id_t cmd;
   if (current_request == -1)
   {
      return FALSE;
   }
   cmd = pending_requests[current_request].cmd;
   return
      (
         /*[CC_TEST_UNSTALLS_REQUEST_SWITCH]*/
         ((cmd == CMD_CCTRL_EVICT) && unstalls_evict())
         || ((cmd == CMD_CCTRL_LOAD) && unstalls_load())
         || ((cmd == CMD_CCTRL_STORE) && unstalls_store())
         /*[/CC_TEST_UNSTALLS_REQUEST_SWITCH]*/
      );
}
/* Handles the activation of a previously stalled request. */
void handle_unstalling ()
{
   const cmd_id_t cmd = pending_requests[current_request].cmd;
   /*[CC_UNSTALL_REQUEST_SWITCH]*/
   if (cmd == CMD_CCTRL_LOAD)
   {
      handle_stalled_load();
   }
   else if (cmd == CMD_CCTRL_STORE)
   {
      handle_stalled_store();
   }
   else if (cmd == CMD_CCTRL_EVICT)
   {
      handle_stalled_evict();
   }
   /*[/CC_UNSTALL_REQUEST_SWITCH]*/
}
void load_next_relevant_request (const addr_t relevant_addr)
{
   int i;
   if (current_request == -1)
   {
      return;
   }
    for (i = current_request; i < REQ_BUFFER_SIZE; ++i)
    {
        if (pending_requests[i].addr == ADDR_T_NULL)
        {
            current_request = -1;
            return;
        }
        if (pending_requests[i].addr == relevant_addr)
        {
            current_request = i;
            return;
        }
    }
    current_request = -1;
}
void load_first_request_for (const cmd_id_t cmd, const addr_t addr)
{
   int i;
   current_request = 0;
   if
   (
      (pending_requests[0].addr == addr)
      && (pending_requests[0].cmd == /*[CMD_CCTRL_EVICT]*/CMD_CCTRL_EVICT/*[/CMD_CCTRL_EVICT]*/)
   )
   {
      // Possible race condition with the eviction policy, ignore this req.
      current_request = 1;
   }
   for (i = current_request; i < REQ_BUFFER_SIZE; ++i)
   {
      if (pending_requests[i].addr == addr)
      {
         if (pending_requests[i].cmd == cmd)
         {
            current_request = i;
         }
         else
         {
            // I either failed to model the protocol correctly, or failed to
            // understand it. Let's crash.
            pending_requests[-1].cmd = 0;
         }
         return;
      }
   }
   // I either failed to model the protocol correctly, or failed to
   // understand it. Let's crash.
   pending_requests[-1].cmd = 0;
}
void cmd_hit (const cmd_id_t cmd)
{
   load_first_request_for(cmd, cache_lines[current_line].addr);
   mark_request_as_completed();
   current_request = 0;
}
/**** Transitions *************************************************************/
void load_next_pending_request ()
{
   current_request = 0;
   current_line = get_line_of(pending_requests[0].addr, cache_lines);
}
void keep_unstalling_requests ()
{
   handle_unstalling();
   load_next_relevant_request(cache_lines[current_line].addr);
}
void handle_unstalling_requests ()
{
   if (current_line == -1)
   {
      current_request = -1;
      return;
   }
   current_request = 0;
   load_next_relevant_request(cache_lines[current_line].addr);
}
cmp_id_t get_ack_to ()
{
    return completed_requests[0].requester;
}
bool is_own_request ()
{
   return (pending_requests[current_request].requester == ID);
}
bool has_completed_auto_evict ()
{
   return (has_completed_request() && completed_requests[0].requester == ID);
}
/******************************************************************************/
/** Communication Management **************************************************/
/******************************************************************************/
msg_content_t msg_in;
bool should_send_data_as_reply_flag = FALSE;
bool should_send_data_to_mem_flag = FALSE;
/**** Internal ****************************************************************/
/**************/
/**** Sending */
/**************/
void emit_message_content ()
{
   transient_msg = msg_in;
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
   //msg_in.addr_t_params[0] = cache_lines[current_line].addr;
   //msg_in = DEFAULT_MSG;
}
/* TODO: sending protocol specific data type. */
void send_data_as_reply ()
{
   transient_msg = msg_in;
   transient_msg.cmd_id_t_param = CMD_DATA_MSG;
   transient_msg.cmp_id_t_params[CMP_ID_T_RECEIVER_PARAM] =
      transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
}
void send_data_to_mem ()
{
   transient_msg = msg_in;
   transient_msg.cmd_id_t_param = CMD_DATA_MSG;
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
   transient_msg.cmp_id_t_params[CMP_ID_T_RECEIVER_PARAM] = MEM_ID;
}
/****************/
/**** Receiving */
/****************/
cmp_id_t get_emitter ()
{
    return msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
}
bool is_own_message ()
{
   return (msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] == ID);
}
/*[CC_HANDLE_BUS_ACCESS]*/
void handle_own_get_modified ()
{
   /** [TEST][HANDLE_OWN_GET_MODIFIED] **/
   if (relevant_line_is(MSI_IM_BD))
   {
      set_relevant_line_to(MSI_IM_D);
   }
   else if (relevant_line_is(MSI_IM_B))
   {
      set_relevant_line_to(MSI_MODIFIED);
      cmd_hit(CMD_CCTRL_STORE);
   }
   else if (relevant_line_is(MSI_SM_BD))
   {
      set_relevant_line_to(MSI_SM_D);
   }
   else if (relevant_line_is(MSI_SM_B))
   {
      set_relevant_line_to(MSI_MODIFIED);
      cmd_hit(CMD_CCTRL_STORE);
   }
}
void handle_own_get_shared ()
{
   /** [TEST][HANDLE_OWN_GET_SHARED] **/
   if (relevant_line_is(MSI_IS_BD))
   {
      set_relevant_line_to(MSI_IS_D);
   }
   else if (relevant_line_is(MSI_IS_B))
   {
      set_relevant_line_to(MSI_SHARED);
      cmd_hit(CMD_CCTRL_LOAD);
   }
}
void handle_own_put_modified ()
{
   /** [TEST][HANDLE_OWN_PUT_MODIFIED] **/
   if (relevant_line_is(MSI_MI_B))
   {
      set_relevant_line_to(MSI_INVALID);
      /* TODO: prepare msg_in... */
      /*
       * Assumed an error in the book "send data to requestor" on own request...
       */
      should_send_data_to_mem_flag = TRUE;
   }
   else if (relevant_line_is(MSI_II_B))
   {
      set_relevant_line_to(MSI_INVALID);
   }
}
/*[/CC_HANDLE_BUS_ACCESS]*/
/*[CC_HANDLE_QUERY]*/
void handle_get_modified ()
{
   /** [TEST][HANDLE_GET_MODIFIED] **/
   if (relevant_line_is(MSI_IS_D))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_IS_D_I);
   }
   else if (relevant_line_is(MSI_IM_D))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      cache_lines[current_line].reply_to = get_emitter();
      set_relevant_line_to(MSI_IM_D_I);
   }
   else if (relevant_line_is(MSI_IM_D_S))
   {
      set_relevant_line_to(MSI_IM_D_SI);
   }
   else if (relevant_line_is(MSI_SHARED))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_INVALID);
   }
   else if (relevant_line_is(MSI_SM_BD))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_IM_BD);
   }
   else if (relevant_line_is(MSI_SM_D))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      cache_lines[current_line].reply_to = get_emitter();
      set_relevant_line_to(MSI_SM_D_I);
   }
   else if (relevant_line_is(MSI_SM_B))
   {
      set_relevant_line_to(MSI_IM_B);
   }
   else if (relevant_line_is(MSI_SM_D_S))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_SM_D_SI);
   }
   else if (relevant_line_is(MSI_MODIFIED))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_INVALID);
      should_send_data_as_reply_flag = TRUE;
   }
   else if (relevant_line_is(MSI_MI_B))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_II_B);
      should_send_data_as_reply_flag = TRUE;
   }
}
void handle_get_shared ()
{
   /** [TEST][HANDLE_GET_SHARED] **/
   if (relevant_line_is(MSI_IM_D))
   {
      mark_as_being(INTERFERENCE_DEMOTING);
      cache_lines[current_line].reply_to = get_emitter();
      set_relevant_line_to(MSI_IM_D_S);
   }
   else if (relevant_line_is(MSI_SM_D))
   {
      mark_as_being(INTERFERENCE_DEMOTING);
      cache_lines[current_line].reply_to = get_emitter();
      set_relevant_line_to(MSI_SM_D_S);
   }
   else if (relevant_line_is(MSI_MODIFIED))
   {
      mark_as_being(INTERFERENCE_DEMOTING);
      set_relevant_line_to(MSI_SHARED);
      should_send_data_as_reply_flag = TRUE;
      should_send_data_to_mem_flag = TRUE;
   }
   else if (relevant_line_is(MSI_MI_B))
   {
      mark_as_being(INTERFERENCE_EXPELLING);
      set_relevant_line_to(MSI_II_B);
      should_send_data_as_reply_flag = TRUE;
      should_send_data_to_mem_flag = TRUE;
   }
}
void handle_put_modified ()
{
}
/*[/CC_HANDLE_QUERY]*/
void parse_bus_message ()
{
   cmd_id_t req_in;
   msg_in = transient_msg;
   cache_local_address_infos
   [
      msg_in.addr_t_params[0]
   ].potential_interference_count[INTERFERENCE_MINOR] += 1;
   current_line = get_line_of(msg_in.addr_t_params[0], cache_lines);
   should_send_data_to_mem_flag = FALSE;
   should_send_data_as_reply_flag = FALSE;
   req_in = msg_in.cmd_id_t_param;
   if (is_own_message())
   {
      /*[CC_HANDLE_BUS_ACCESS_SWITCH]*/
      if (req_in == CMD_CCTRL_GET_SHARED)
      {
         handle_own_get_shared();
      }
      else if (req_in == CMD_CCTRL_GET_MODIFIED)
      {
         handle_own_get_modified();
      }
      else if (req_in == CMD_CCTRL_PUT_MODIFIED)
      {
         handle_own_put_modified();
      }
      /*[/CC_HANDLE_BUS_ACCESS_SWITCH]*/
   }
   else
   {
      /*[CC_HANDLE_QUERY_SWITCH]*/
      if (req_in == CMD_CCTRL_GET_SHARED)
      {
         handle_get_shared();
      }
      else if (req_in == CMD_CCTRL_GET_MODIFIED)
      {
         handle_get_modified();
      }
      else if (req_in == CMD_CCTRL_PUT_MODIFIED)
      {
         handle_put_modified();
      }
      /*[/CC_HANDLE_QUERY_SWITCH]*/
   }
}
/*[CC_HANDLE_REQUEST]*/
void handle_evict (pending_request_t req)
{
   /** [TEST][HANDLE_EVICT] **/
   if (relevant_line_is(MSI_INVALID))
   {
      req.is_cache_hit = TRUE;
      cache_local_address_infos[req.addr].hit += 1;
      push_new_pending_request(completed_requests, REQ_BUFFER_SIZE, req);
   }
   else if (relevant_line_is(MSI_SHARED))
   {
      set_relevant_line_to(MSI_INVALID);
      req.is_cache_hit = TRUE;
      cache_local_address_infos[req.addr].hit += 1;
      push_new_pending_request(completed_requests, REQ_BUFFER_SIZE, req);
   }
   else if (relevant_line_is(MSI_MODIFIED))
   {
      req.is_cache_hit = FALSE;
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_PUT_MODIFIED;
      set_relevant_line_to(MSI_MI_B);
   }
   else
   {
      /** Stalled: Neither miss nor hit, it's TBD... **/
      req.is_cache_hit = TRUE;
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
   }
}
void handle_store (pending_request_t req)
{
   /** [TEST][HANDLE_STORE] **/
   if (relevant_line_is(MSI_INVALID))
   {
      clear_interference_by_writing();
      propagate_use_count(current_line);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_GET_MODIFIED;
      req.is_cache_hit = FALSE;
      set_relevant_line_to(MSI_IM_BD);
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
   }
   else if (relevant_line_is(MSI_SHARED))
   {
      clear_interference_by_writing();
      propagate_use_count(current_line);
      req.is_cache_hit = FALSE;
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_GET_MODIFIED;
      set_relevant_line_to(MSI_SM_BD);
   }
   else if
   (
      relevant_line_is(MSI_MODIFIED)
      || relevant_line_is(MSI_MI_B)
   )
   {
      clear_interference_by_writing();
      propagate_use_count(current_line);
      req.is_cache_hit = TRUE;
      cache_local_address_infos[req.addr].hit += 1;
      push_new_pending_request(completed_requests, REQ_BUFFER_SIZE, req);
   }
   else
   {
      /** Stalled: Neither miss nor hit, it's TBD... **/
      req.is_cache_hit = TRUE;
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
   }
}
void handle_load (pending_request_t req)
{
   /** [TEST][HANDLE_LOAD] **/
   if (relevant_line_is(MSI_INVALID))
   {
      clear_interference_by_reading();
      propagate_use_count(current_line);
      req.is_cache_hit = FALSE;
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
      current_query.author = ID;
      current_query.addr = cache_lines[current_line].addr;
      current_query.cmd = CMD_CCTRL_GET_SHARED;
      set_relevant_line_to(MSI_IS_BD);
   }
   else if
   (
      relevant_line_is(MSI_SHARED)
      || relevant_line_is(MSI_SM_BD)
      || relevant_line_is(MSI_SM_D)
      || relevant_line_is(MSI_SM_B)
      || relevant_line_is(MSI_SM_D_I)
      || relevant_line_is(MSI_SM_D_S)
      || relevant_line_is(MSI_SM_D_SI)
      || relevant_line_is(MSI_MODIFIED)
      || relevant_line_is(MSI_MI_B)
   )
   {
      /*
       * It's actually a bit more complicated than that: all the MSI_SM_* are
       * cache hits on the value BEFORE the write occurs...
       */
      clear_interference_by_reading();
      propagate_use_count(current_line);
      req.is_cache_hit = TRUE;
      cache_local_address_infos[req.addr].hit += 1;
      push_new_pending_request(completed_requests, REQ_BUFFER_SIZE, req);
   }
   else
   {
      /** Stalled: Neither miss nor hit, it's TBD... **/
      req.is_cache_hit = TRUE;
      push_new_pending_request(pending_requests, REQ_BUFFER_SIZE, req);
   }
}
/*[/CC_HANDLE_REQUEST]*/
void parse_request ()
{
   cmd_id_t req_cmd;
   pending_request_t req;
   msg_in = transient_msg;
   transient_msg = DEFAULT_MSG;
   req.cmd = msg_in.cmd_id_t_param;
   req.addr = msg_in.addr_t_params[0];
   req.requester = get_emitter();
   req_cmd = req.cmd;
   current_line = get_line_of(req.addr, cache_lines);
   if (current_line == -1)
   {
      /* Cache is full and doesn't have a line for this address. */
      req.is_cache_hit = FALSE;
      blocked_request = req;
      current_line = least_recently_used_line;
      req_cmd = /*[CMD_CCTRL_EVICT]*/CMD_CCTRL_EVICT/*[/CMD_CCTRL_EVICT]*/;
      req.addr = cache_lines[least_recently_used_line].addr;
      req.cmd = /*[CMD_CCTRL_EVICT]*/CMD_CCTRL_EVICT/*[/CMD_CCTRL_EVICT]*/;
      req.requester = ID;
      req.is_cache_hit = TRUE;
   }
   /*
    * current_line may be pointing at an invalidated line with a different
    * address. This makes sure the line is dedicated to the right address.
    */
   cache_lines[current_line].addr = req.addr;
   /* The cache has a line with this address, apply req or stall. */
   /*[CC_HANDLE_REQUEST_SWITCH]*/
   if (req_cmd == CMD_CCTRL_LOAD)
   {
      handle_load(req);
   }
   else if (req_cmd == CMD_CCTRL_STORE)
   {
      handle_store(req);
   }
   else if (req_cmd == CMD_CCTRL_EVICT)
   {
      handle_evict(req);
   }
   /*[/CC_HANDLE_REQUEST_SWITCH]*/
}
void unblock_request ()
{
   cmd_id_t req_cmd;
   req_cmd = blocked_request.cmd;
   current_line = get_line_of(blocked_request.addr, cache_lines);
   /*
    * current_line may be pointing at an invalidated line with a different
    * address. This makes sure the line is dedicated to the right address.
    */
   cache_lines[current_line].addr = blocked_request.addr;
   /* The cache has a line with this address, apply req or stall. */
   /*[CC_HANDLE_REQUEST_SWITCH]*/
   if (req_cmd == CMD_CCTRL_LOAD)
   {
      handle_load(blocked_request);
   }
   else if (req_cmd == CMD_CCTRL_STORE)
   {
      handle_store(blocked_request);
   }
   else if (req_cmd == CMD_CCTRL_EVICT)
   {
      handle_evict(blocked_request);
   }
   /*[/CC_HANDLE_REQUEST_SWITCH]*/
   blocked_request = DEFAULT_PENDING_REQUEST_VALUE;
}
void send_completed_request_data ()
{
   const pending_request_t req = completed_requests[0];
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
   transient_msg.addr_t_params[0] = req.addr;
   transient_msg.cmd_id_t_param = req.cmd;
   pop_pending_request_at
   (
      completed_requests,
      REQ_BUFFER_SIZE,
      0
   );
}
/**** Transitions *************************************************************/
bool should_send_data_as_reply ()
{
   return should_send_data_as_reply_flag;
}
bool should_send_data_to_mem ()
{
   return should_send_data_to_mem_flag;
}
bool should_send_data ()
{
   return (should_send_data_as_reply_flag || should_send_data_to_mem_flag);
}
bool should_emit_query ()
{
   return (current_query.addr != ADDR_T_NULL);
}
void sent_data_as_reply ()
{
   should_send_data_as_reply_flag = FALSE;
}
void sent_data_to_mem ()
{
   should_send_data_to_mem_flag = FALSE;
}
void emit_query ()
{
   reset_transient_msg();
   transient_msg.addr_t_params[0] = current_query.addr;
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = current_query.author;
   transient_msg.cmd_id_t_param = current_query.cmd;
   current_query = DEFAULT_QUERY_VALUE;
}
void set_emitter_from_cache_line ()
{
   msg_in.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] =
      cache_lines[current_line].reply_to;
}
void add_bus_master ()
{
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = ID;
}
/*[CC_HANDLE_DATA]*/
/*[/CC_HANDLE_DATA]*/
void handle_data_reception ()
{
   msg_in = transient_msg;
   should_send_data_to_mem_flag = FALSE;
   should_send_data_as_reply_flag = FALSE;
   current_line = get_line_of(msg_in.addr_t_params[0], cache_lines);
   /*[CC_HANDLE_DATA_SWITCH]*/
   if (relevant_line_is(MSI_IS_BD))
   {
      set_relevant_line_to(MSI_IS_B);
   }
   else if (relevant_line_is(MSI_IS_D))
   {
      set_relevant_line_to(MSI_SHARED);
      cmd_hit(CMD_CCTRL_LOAD);
   }
   else if (relevant_line_is(MSI_IS_D_I))
   {
      cmd_hit(CMD_CCTRL_LOAD);
      set_relevant_line_to(MSI_INVALID);
   }
   else if (relevant_line_is(MSI_IM_BD))
   {
      set_relevant_line_to(MSI_IM_B);
   }
   else if (relevant_line_is(MSI_IM_D))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_relevant_line_to(MSI_MODIFIED);
   }
   else if (relevant_line_is(MSI_IM_D_I))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_emitter_from_cache_line();
      should_send_data_as_reply_flag = TRUE;
      set_relevant_line_to(MSI_INVALID);
   }
   else if (relevant_line_is(MSI_IM_D_S))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_emitter_from_cache_line();
      should_send_data_as_reply_flag = TRUE;
      should_send_data_to_mem_flag = TRUE;
      set_relevant_line_to(MSI_SHARED);
   }
   else if (relevant_line_is(MSI_IM_D_SI))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_emitter_from_cache_line();
      should_send_data_as_reply_flag = TRUE;
      should_send_data_to_mem_flag = TRUE;
      set_relevant_line_to(MSI_INVALID);
   }
   else if (relevant_line_is(MSI_SM_BD))
   {
      set_relevant_line_to(MSI_SM_B);
   }
   else if (relevant_line_is(MSI_SM_D))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_relevant_line_to(MSI_MODIFIED);
   }
   else if (relevant_line_is(MSI_SM_D_I))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_emitter_from_cache_line();
      should_send_data_as_reply_flag = TRUE;
      set_relevant_line_to(MSI_INVALID);
   }
   else if (relevant_line_is(MSI_SM_D_S))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_emitter_from_cache_line();
      should_send_data_as_reply_flag = TRUE;
      should_send_data_to_mem_flag = TRUE;
      set_relevant_line_to(MSI_SHARED);
      cache_lines[current_line].reply_to = CMP_ID_T_NULL;
   }
   else if (relevant_line_is(MSI_SM_D_SI))
   {
      cmd_hit(CMD_CCTRL_STORE);
      set_emitter_from_cache_line();
      should_send_data_as_reply_flag = TRUE;
      should_send_data_to_mem_flag = TRUE;
      set_relevant_line_to(MSI_INVALID);
   }
   /*[/CC_HANDLE_DATA_SWITCH]*/
}
/******************************************************************************/
/** Initialization ************************************************************/
/******************************************************************************/
void initialize ()
{
   int i, j;
   current_query = DEFAULT_QUERY_VALUE;
   for (i = 0; i < LINES_PER_CACHE; i++)
   {
      cache_lines[i] = DEFAULT_CACHE_LINE_VALUE;
      cache_lines[i].last_use = i;
   }
   for (i = 0; i < REQ_BUFFER_SIZE; i++)
   {
      pending_requests[i] = DEFAULT_PENDING_REQUEST_VALUE;
      completed_requests[i] = DEFAULT_PENDING_REQUEST_VALUE;
   }
   for (i = 0; i < LAST_ADDR; ++i)
   {
      cache_local_address_infos[i].hit = 0;
      cache_local_address_infos[i].miss = 0;
      for (j = 0; j < INTERFERENCE_TYPES; ++j)
      {
         cache_local_address_infos[i].interference_count[j] = 0;
         cache_local_address_infos[i].potential_interference_count[j] = 0;
      }
   }
   blocked_request = DEFAULT_PENDING_REQUEST_VALUE;
}
void clean ()
{
    current_line = -1;
    current_request = -1;
    should_send_data_as_reply_flag = FALSE;
    should_send_data_to_mem_flag = FALSE;
    current_query = DEFAULT_QUERY_VALUE;
    msg_in = DEFAULT_MSG;
}
void is_ready ()
{
    is_ready_for_bus[ID] = TRUE;
}
void is_busy ()
{
    is_ready_for_bus[ID] = FALSE;
}
/**** Validation *************************************************************/
// TODO: CoProSwi support.
bool is_compatible_with (const msi_state_t s0, const msi_state_t s1)
{
   return
   (
      !((s0 == MSI_MODIFIED) && ((s1 == MSI_SHARED) || (s1 == MSI_MODIFIED)))
      && !((s1 == MSI_MODIFIED) && ((s0 == MSI_SHARED) || (s0 == MSI_MODIFIED)))
   );
}
bool addr_states_are_compatible (const addr_t addr, const cache_line_t &c0[LINES_PER_CACHE], const cache_line_t &c1[LINES_PER_CACHE])
{
   return is_compatible_with(get_state_of(addr, c0), get_state_of(addr, c1));
}
state
    S5,
    S4 { clk <= C2C_DATA_TIME },
    S2 { clk <= QUERY_HANDLING_TIME },
    S1,
    S3,
    Ready,
    S0;
commit
    S0;
init
    S0;
trans
    Ready -> S5 { guard has_completed_auto_evict(); sync FORCE_EXTRA_URGENT!; assign send_completed_request_data(),
unblock_request(); },
    S5 -> Ready { guard !should_unstall()
&& !should_emit_query(); sync FORCE_URGENT!; assign clean(); },
    S5 -> S5 { guard should_emit_query(); sync QUERY_OUT[ID]!; assign emit_query(); },
    S5 -> S5 { guard should_unstall()
&&!should_emit_query(); sync FORCE_URGENT!; assign keep_unstalling_requests(); },
    S4 -> S3 { guard clk == C2C_DATA_TIME; sync MAX_PRIORITY!; },
    S2 -> S3 { guard clk == QUERY_HANDLING_TIME; sync MAX_PRIORITY!; },
    S0 -> S1 { sync ADD_BUS_MASTER!; assign add_bus_master(); },
    Ready -> Ready { guard has_completed_request(); sync CPU_ACK[get_ack_to()]!; assign send_completed_request_data(),
clean(); },
    S3 -> S5 { guard !should_send_data(); sync FORCE_EXTRA_URGENT!; assign handle_unstalling_requests(); },
    S3 -> S3 { guard should_send_data_to_mem(); sync DATA_OUT[ID]!; assign send_data_to_mem(),
sent_data_to_mem(); },
    S3 -> S4 { guard should_send_data_as_reply()
&& !should_send_data_to_mem(); sync DATA_OUT[ID]!; assign send_data_as_reply(),
sent_data_as_reply(),
clk = 0; },
    Ready -> S2 { sync QUERY_IN[ID]?; assign parse_bus_message(),
clk = 0; },
    Ready -> S5 { guard !has_completed_request()
&& can_take_requests(); sync CPU_REQ[ID]?; assign parse_request(); },
    Ready -> S3 { sync DATA_IN[ID]?; assign handle_data_reception(); },
    S1 -> Ready { sync SYS_INIT?; assign initialize(),
clean(); };
}
process QueryFIFO(cmp_id_t CCTRL_ID) {
const int IN_QUERY_BUFFER_SIZE = 5;
const int OUT_QUERY_BUFFER_SIZE = IN_QUERY_BUFFER_SIZE;
const int MAX_QUERY_BUFFER_SIZE = IN_QUERY_BUFFER_SIZE;
query_t in_queries[MAX_QUERY_BUFFER_SIZE];
query_t out_queries[MAX_QUERY_BUFFER_SIZE];
void pop
(
   query_t &array[MAX_QUERY_BUFFER_SIZE],
   const int queue_size
)
{
   int i;
   for (i = 1; i < queue_size; ++i)
   {
      /* No "break" in UPPAAL. */
      if (array[i - 1].addr == ADDR_T_NULL)
      {
         array[i - 1] = array[i];
         i = queue_size;
      }
      else
      {
         array[i - 1] = array[i];
      }
   }
   array[queue_size - 1] = DEFAULT_QUERY_VALUE;
}
void push
(
   query_t &array[MAX_QUERY_BUFFER_SIZE],
   const int queue_size,
   const query_t msg
)
{
   int i;
   for (i = 0; i < queue_size; ++i)
   {
      if (array[i].addr == ADDR_T_NULL)
      {
         array[i] = msg;
         return;
      }
   }
}
void push_query (query_t &array[MAX_QUERY_BUFFER_SIZE], const int array_size)
{
   query_t query0;
   query0.addr = transient_msg.addr_t_params[0];
   query0.cmd = transient_msg.cmd_id_t_param;
   query0.author = transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   push
   (
      array,
      array_size,
      query0
   );
}
void pop_query (query_t &array[MAX_QUERY_BUFFER_SIZE], const int array_size)
{
   const query_t query0 = array[0];
   reset_transient_msg();
   transient_msg.addr_t_params[0] = query0.addr;
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = query0.author;
   transient_msg.cmd_id_t_param = query0.cmd;
   pop(array, array_size);
}
/**** Transitions *************************************************************/
bool in_queries_not_empty ()
{
   return (in_queries[0].addr != ADDR_T_NULL);
}
bool out_queries_not_empty ()
{
   return (out_queries[0].addr != ADDR_T_NULL);
}
bool in_queries_not_full ()
{
   return (in_queries[IN_QUERY_BUFFER_SIZE - 1].addr == ADDR_T_NULL);
}
bool out_queries_not_full ()
{
   return (out_queries[OUT_QUERY_BUFFER_SIZE - 1].addr == ADDR_T_NULL);
}
void pop_in_query ()
{
   pop_query(in_queries, IN_QUERY_BUFFER_SIZE);
   transient_msg.cmp_id_t_params[CMP_ID_T_RECEIVER_PARAM] = CCTRL_ID;
   is_ready_for_bus[CCTRL_ID] = TRUE;
}
void pop_out_query ()
{
   pop_query(out_queries, OUT_QUERY_BUFFER_SIZE);
   transient_msg.cmp_id_t_params[CMP_ID_T_RECEIVER_PARAM] =
      transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM];
   transient_msg.cmp_id_t_params[CMP_ID_T_EMITTER_PARAM] = CCTRL_ID;
   has_use_for_bus[CCTRL_ID] = out_queries_not_empty();
}
void push_in_query ()
{
   push_query(in_queries, IN_QUERY_BUFFER_SIZE);
   is_ready_for_bus[CCTRL_ID] = in_queries_not_full();
}
void push_out_query ()
{
   push_query(out_queries, OUT_QUERY_BUFFER_SIZE);
   has_use_for_bus[CCTRL_ID] = TRUE;
}
void initialize ()
{
   int i;
   for (i = 0; i < MAX_QUERY_BUFFER_SIZE; ++i)
   {
      in_queries[i] = DEFAULT_QUERY_VALUE;
      out_queries[i] = DEFAULT_QUERY_VALUE;
   }
} 
state
    S0,
    Ready;
init
    S0;
trans
    S0 -> Ready { sync SYS_INIT?; assign initialize(); },
    Ready -> Ready { guard out_queries_not_empty(); sync QUERY_TO_BUS[CCTRL_ID]!; assign pop_out_query(); },
    Ready -> Ready { guard out_queries_not_full(); sync QUERY_OUT[CCTRL_ID]?; assign push_out_query(); },
    Ready -> Ready { guard in_queries_not_empty(); sync QUERY_IN[CCTRL_ID]!; assign pop_in_query(); },
    Ready -> Ready { sync QUERY_BROADCAST?; assign push_in_query(); };
}
// Automaton allowing the URGENT transitions.
UrgentHandler = ForceUrgent();
// Query Bus (ID = 0)
QBus0 = QueryBus(0);
// Memory Controller (ID = 2) & associated Data FIFO (OWNER_ID = 2).
Mem0 = MemoryCTRL(2); DFIFOMem = DataFIFO(2);
// Coherency Manager (ID = 1, MEM_ID = 2)
Coherency0 = CoherencyMGR(1, 2);
// Caches
// Each line is:
// Cache (ID = x, MEM_ID = 2), associated query FIFO (OWNER_ID = x), and data
// FIFO (OWNER_ID = x).
// If you change the number of caches, don't forget to update the CORE_COUNT
// constant in the system declaration.
// Also ensure that the value of COMPONENT_COUNT is higher than the highest
// ID you attributed.
CCTRL0 = MSICacheCTRL(3, 2); QFIO0 = QueryFIFO(3); DFIFO0 = DataFIFO(3);
CCTRL1 = MSICacheCTRL(4, 2); QFIO1 = QueryFIFO(4); DFIFO1 = DataFIFO(4);
CCTRL2 = MSICacheCTRL(5, 2); QFIO2 = QueryFIFO(5); DFIFO2 = DataFIFO(5);
CCTRL3 = MSICacheCTRL(6, 2); QFIO3 = QueryFIFO(6); DFIFO3 = DataFIFO(6);
// Cores
// Each line is: (ID, CACHE_ID, PROGRAM_ID)
// Programs can be found in the Core template's declaration.
Test0a = Core(1, 3, 202);
//Test1a = Core(10, 4, 200);
//Test2a = Core(11, 5, 200);
//Test3a = Core(12, 6, 200);
system
        DFIFO0, CCTRL0, QFIO0, Test0a,
//        DFIFO1, CCTRL1, QFIO1, Test1a,
//        DFIFO2, CCTRL2, QFIO2, Test2a,
//        DFIFO3, CCTRL3, QFIO3, Test3a,
        QBus0, Mem0, DFIFOMem, Coherency0, UrgentHandler
        ;
